#include <errno.h>
#include <string.h>
#include <iostream>
#include <fstream>
#include <algorithm>
#include <sstream>

#include "HTTPMsgTester.h"
#include "HTTPConnection.h"

using std::cout;
using std::cerr;
using std::endl;
using std::vector;
using std::ostream;
using std::string;
using std::fstream;
using std::ios_base;
using std::stringstream;

HTTPMsgTester::HTTPMsgTester()
{
	file_ = getenv("STAPLE_HTTP_TEST_OUTPUT");
}

HTTPMsgTester::~HTTPMsgTester()
{
	for (MsgVector::iterator it = msgs_.begin(); it != msgs_.end(); ++it)
		delete *it;
}

void HTTPMsgTester::addMessage(const HTTPConnection* conn, const HTTPMsg* msg)
{
	if (file_)
		msgs_.push_back(new MsgDetails(*conn, *msg));
}

void HTTPMsgTester::printOutput()
{
	if (!file_)
		return;

	fstream fout(file_, ios_base::out|ios_base::trunc);
	if (!fout.is_open()) {
		cerr << "Failed to open test output file: '" << file_ << "': " << strerror(errno) << '\n';
	} else {
		printTestOutput(fout);
		fout.close();
	}
}

/* This is a slightly complicated set-up to produce output which can
 * be compared with the output from tshark as generated by
 * test/genexpected.sh. This output is compared to the output from
 * tshark in the tests.
 */

/* We want to sort all the HTTPMsgs we have on time, but we want to
 * split the requests from the responses. The classes HTTPMsgBase,
 * HTTPMsgReq, and HTTPMsgRsp takes care of this.
 */
struct HTTPMsgBase
{
	const HTTPMsgTester::MsgDetails* msgDetails;
	virtual void print(ostream& o) const = 0;
	virtual Timeval getTime() const = 0;
};

struct HTTPMsgReq : public HTTPMsgBase
{
	HTTPMsgReq(const HTTPMsgTester::MsgDetails* md)
		{
			msgDetails = md;
		}
	virtual void print(ostream& o) const
		{
			o << msgDetails->connectionInfoReq_;
			msgDetails->msg.printReqTestOutput(o);
		}
	virtual Timeval getTime() const
		{ return msgDetails->msg.getReqStartTime(); }

};

struct HTTPMsgRsp : public HTTPMsgBase
{
	HTTPMsgRsp(const HTTPMsgTester::MsgDetails* md)
		{
			msgDetails = md;
		}
	virtual void print(ostream& o) const
		{
			o << msgDetails->connectionInfoRsp_;
			msgDetails->msg.printRspTestOutput(o);
		}
	virtual Timeval getTime() const
		{ return msgDetails->msg.getRspEndTime(); }
};

/* Our comparison predicate sorts on time. */
struct HTTPMsgCmp
{
	bool operator()(const HTTPMsgBase* a, const HTTPMsgBase* b)
		{
			const struct timeval& at = a->getTime().getTimeval();
			const struct timeval& bt = b->getTime().getTimeval();

			if (at.tv_sec < bt.tv_sec)
				return true;
			else if (at.tv_sec == bt.tv_sec)
				return at.tv_usec < bt.tv_usec;
			else
				return false;
		}
};

void HTTPMsgTester::printTestOutput(std::ostream& o) const
{
	vector<HTTPMsgBase*> msgs;
	for (MsgVector::const_iterator it = msgs_.begin(); it != msgs_.end(); ++it) {
		msgs.push_back(new HTTPMsgReq(*it));
		msgs.push_back(new HTTPMsgRsp(*it));
	}

	/* When requests are pipelined there can be more than one
	 * request in a single packet. In this case the timestamps of
	 * the two requests will be equal. We therefore need a stable
	 * sort here, plain std::sort is not sufficient.
	 */
	std::stable_sort(msgs.begin(), msgs.end(), HTTPMsgCmp());
	for (vector<HTTPMsgBase*>::iterator it = msgs.begin(); it != msgs.end(); ++it) {
		(*it)->print(o);
		o << '\n';
	}
}

HTTPMsgTester::MsgDetails::MsgDetails(const HTTPConnection& conn, const HTTPMsg& m) : msg(m)
{
	stringstream ssReq;
	conn.printTestOutput(ssReq, false);
	connectionInfoReq_ = ssReq.str();

	stringstream ssRsp;
	conn.printTestOutput(ssRsp, true);
	connectionInfoRsp_ = ssRsp.str();
}

HTTPMsgTester::MsgDetails::~MsgDetails()
{ }
